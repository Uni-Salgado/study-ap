import React, { useState, useMemo, useRef, useEffect } from 'react';
import { 
  BookOpen, Search, Grid, RotateCw, Check, X, Trophy, 
  ArrowLeft, HelpCircle, Plus, Upload, FileText, Trash2, 
  Save, Wand2, File, Sparkles, Hand
} from 'lucide-react';

// --- DADOS INICIAIS ---
const INITIAL_DECKS = [
  {
    id: "biologia_celular",
    titulo: "Biologia Celular",
    cartas: [
      { termo: "MITOCONDRIA", definicao: "Respons√°vel pela respira√ß√£o celular e energia.", dica: "Come√ßa com M, usina de for√ßa." },
      { termo: "RIBOSSOMO", definicao: "Realiza a s√≠ntese de prote√≠nas.", dica: "Pequenas estruturas granulares." },
      { termo: "LISOSSOMO", definicao: "Respons√°vel pela digest√£o celular.", dica: "Limpeza da c√©lula." },
      { termo: "NUCLEO", definicao: "Cont√©m o material gen√©tico (DNA).", dica: "Centro de comando." },
      { termo: "CITOPLASMA", definicao: "Material gelatinoso onde as organelas flutuam.", dica: "Preenche a c√©lula." },
      { termo: "MEMBRANA", definicao: "Pelicula que envolve a c√©lula.", dica: "Porteiro da c√©lula." },
      { termo: "CLOROPLASTO", definicao: "Realiza a fotoss√≠ntese em vegetais.", dica: "Verde." },
      { termo: "VACUOLO", definicao: "Armazena subst√¢ncias e regula √°gua.", dica: "Grande bolsa." }
    ]
  }
];

// --- FLASHCARDS (Mantido, mas agora alimentado pelo gerador autom√°tico) ---
const FlashcardMode = ({ deck, onExit }) => {
  const [currentIndex, setCurrentIndex] = useState(0);
  const [isFlipped, setIsFlipped] = useState(false);
  const [score, setScore] = useState(0);
  const [completed, setCompleted] = useState(false);

  if (!deck.cartas || deck.cartas.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center h-full p-6 text-center">
        <p className="text-gray-500 mb-4">Este deck est√° vazio.</p>
        <button onClick={onExit} className="text-indigo-600 font-bold">Voltar</button>
      </div>
    );
  }

  const currentCard = deck.cartas[currentIndex];

  const handleNext = (known) => {
    if (known) setScore(score + 1);
    setIsFlipped(false);
    if (currentIndex < deck.cartas.length - 1) {
      setTimeout(() => setCurrentIndex(currentIndex + 1), 300);
    } else {
      setCompleted(true);
    }
  };

  if (completed) {
    return (
      <div className="flex flex-col items-center justify-center h-full p-6 text-center animate-fade-in">
        <Trophy size={64} className="text-yellow-500 mb-4" />
        <h2 className="text-2xl font-bold text-gray-800 mb-2">Sess√£o Conclu√≠da!</h2>
        <p className="text-gray-600 mb-6">Voc√™ dominou {score} de {deck.cartas.length} termos.</p>
        <button onClick={onExit} className="bg-indigo-600 text-white px-6 py-2 rounded-full font-semibold hover:bg-indigo-700 transition">Voltar ao Menu</button>
      </div>
    );
  }

  return (
    <div className="flex flex-col items-center h-full max-w-md mx-auto p-4">
      <div className="w-full flex justify-between items-center mb-4">
        <button onClick={onExit} className="text-gray-500 hover:text-gray-800"><ArrowLeft /></button>
        <span className="text-sm font-medium text-gray-500">Cart√£o {currentIndex + 1} / {deck.cartas.length}</span>
      </div>

      <div className="w-full h-80 relative perspective cursor-pointer mb-8 group" onClick={() => setIsFlipped(!isFlipped)}>
        <div className={`relative w-full h-full transition-all duration-500 transform preserve-3d ${isFlipped ? 'rotate-y-180' : ''}`}>
          <div className="absolute w-full h-full bg-white rounded-2xl shadow-xl border-b-4 border-indigo-200 flex flex-col items-center justify-center p-6 backface-hidden">
            <h3 className="text-indigo-600 font-bold text-sm uppercase tracking-wider mb-4">Defini√ß√£o</h3>
            <p className="text-xl text-center text-gray-800 font-medium">{currentCard.definicao}</p>
            <p className="mt-8 text-xs text-gray-400 flex items-center gap-1"><RotateCw size={12}/> Toque para virar</p>
          </div>
          <div className="absolute w-full h-full bg-indigo-600 rounded-2xl shadow-xl flex flex-col items-center justify-center p-6 backface-hidden rotate-y-180">
            <h3 className="text-indigo-200 font-bold text-sm uppercase tracking-wider mb-4">Termo</h3>
            <p className="text-3xl text-center text-white font-bold break-words w-full">{currentCard.termo}</p>
            <div className="mt-4 p-2 bg-indigo-700 rounded text-indigo-200 text-sm text-center">üí° {currentCard.dica || "Sem dica dispon√≠vel"}</div>
          </div>
        </div>
      </div>

      <div className="flex gap-4 w-full">
        <button onClick={() => handleNext(false)} className="flex-1 py-4 rounded-xl bg-red-100 text-red-600 font-bold hover:bg-red-200 transition flex items-center justify-center gap-2"><X size={20} /> Errei</button>
        <button onClick={() => handleNext(true)} className="flex-1 py-4 rounded-xl bg-green-100 text-green-600 font-bold hover:bg-green-200 transition flex items-center justify-center gap-2"><Check size={20} /> Acertei</button>
      </div>
    </div>
  );
};

// --- CA√áA-PALAVRAS (Atualizado: Drag Selection + M√≠nimo 7 palavras) ---
const WordSearchMode = ({ deck, onExit }) => {
  const GRID_SIZE = 12; // Aumentado para caber mais palavras
  const MIN_WORDS = 7;
  
  // Gera√ß√£o do Grid
  const { grid, wordsToFind } = useMemo(() => {
    // Tenta gerar um grid v√°lido at√© 5 vezes se n√£o conseguir colocar palavras suficientes
    let bestGrid = [];
    let bestWordList = [];
    let maxPlaced = -1;

    for (let attempt = 0; attempt < 10; attempt++) {
        const newGrid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(''));
        const currentPlacedWords = [];
        // Filtra palavras que cabem na grid
        const possibleCards = deck.cartas.filter(c => c.termo.length <= GRID_SIZE);
        // Embaralha para variar
        const shuffledCards = [...possibleCards].sort(() => 0.5 - Math.random());
        
        const directions = [[0, 1], [1, 0], [1, 1], [0, -1], [-1, 0]]; // Horiz, Vert, Diag, Invertido

        shuffledCards.forEach(card => {
            // Se j√° temos muitas palavras, podemos parar (opcional, mas aqui queremos encher)
            let placed = false;
            let tryCount = 0;
            const word = card.termo.replace(/\s/g, '').toUpperCase();

            while (!placed && tryCount < 50) {
                const dir = directions[Math.floor(Math.random() * directions.length)];
                const startRow = Math.floor(Math.random() * GRID_SIZE);
                const startCol = Math.floor(Math.random() * GRID_SIZE);

                let fits = true;
                for (let i = 0; i < word.length; i++) {
                    const r = startRow + i * dir[0];
                    const c = startCol + i * dir[1];
                    if (r < 0 || c < 0 || r >= GRID_SIZE || c >= GRID_SIZE || (newGrid[r][c] !== '' && newGrid[r][c] !== word[i])) {
                        fits = false;
                        break;
                    }
                }

                if (fits) {
                    for (let i = 0; i < word.length; i++) {
                        newGrid[startRow + i * dir[0]][startCol + i * dir[1]] = word[i];
                    }
                    currentPlacedWords.push(word);
                    placed = true;
                }
                tryCount++;
            }
        });

        // Verifica se √© o melhor grid at√© agora
        if (currentPlacedWords.length > maxPlaced) {
            maxPlaced = currentPlacedWords.length;
            bestGrid = newGrid;
            bestWordList = currentPlacedWords;
        }

        // Se conseguimos o m√≠nimo desejado ou usamos todas as cartas dispon√≠veis, paramos
        if (currentPlacedWords.length >= MIN_WORDS || currentPlacedWords.length === possibleCards.length) {
            break;
        }
    }

    // Preencher vazios
    const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    for(let r=0; r<GRID_SIZE; r++){
      for(let c=0; c<GRID_SIZE; c++){
        if(bestGrid[r][c] === '') bestGrid[r][c] = alphabet[Math.floor(Math.random() * alphabet.length)];
      }
    }

    return { grid: bestGrid, wordsToFind: bestWordList };
  }, [deck]);

  // L√≥gica de Intera√ß√£o (Drag)
  const [isDragging, setIsDragging] = useState(false);
  const [startCell, setStartCell] = useState(null); // {r, c}
  const [currentCell, setCurrentCell] = useState(null); // {r, c}
  const [foundWords, setFoundWords] = useState([]);
  const gridRef = useRef(null);

  // Calcula as c√©lulas selecionadas com base no in√≠cio e fim do arrasto
  const getSelectedCells = () => {
    if (!startCell || !currentCell) return [];
    
    const cells = [];
    const dr = currentCell.r - startCell.r;
    const dc = currentCell.c - startCell.c;
    const steps = Math.max(Math.abs(dr), Math.abs(dc));
    
    // Verifica se √© um movimento v√°lido (horiz, vert ou diag perfeito)
    if (steps === 0) return [`${startCell.r}-${startCell.c}`];
    
    // Normaliza dire√ß√£o para 0, 1 ou -1
    const stepR = dr === 0 ? 0 : dr / Math.abs(dr);
    const stepC = dc === 0 ? 0 : dc / Math.abs(dc);

    // S√≥ permite diagonal perfeita (|dr| == |dc|) ou linhas retas
    if (Math.abs(dr) !== Math.abs(dc) && dr !== 0 && dc !== 0) return [`${startCell.r}-${startCell.c}`]; // Sele√ß√£o inv√°lida visualmente mant√©m no start

    for (let i = 0; i <= steps; i++) {
        const r = startCell.r + i * (Math.abs(dr) === Math.abs(dc) || dr !== 0 ? (dr === 0 ? 0 : stepR) : 0);
        const c = startCell.c + i * (Math.abs(dr) === Math.abs(dc) || dc !== 0 ? (dc === 0 ? 0 : stepC) : 0);
        // L√≥gica acima simplificada: se diagonal, move os dois. Se reta, move um.
        // Corre√ß√£o simples:
        const rr = startCell.r + i * stepR;
        const cc = startCell.c + i * stepC;
        cells.push(`${rr}-${cc}`);
    }
    return cells;
  };

  const handleMouseDown = (r, c) => {
    setIsDragging(true);
    setStartCell({r, c});
    setCurrentCell({r, c});
  };

  const handleMouseEnter = (r, c) => {
    if (isDragging) {
      setCurrentCell({r, c});
    }
  };

  const handleMouseUp = () => {
    if (!isDragging || !startCell || !currentCell) return;
    setIsDragging(false);

    // Verificar palavra
    const selectedIds = getSelectedCells();
    const selectedWord = selectedIds.map(id => {
        const [r, c] = id.split('-').map(Number);
        return grid[r][c];
    }).join('');

    // Verifica normal e reverso
    const reversed = selectedWord.split('').reverse().join('');
    
    if (wordsToFind.includes(selectedWord) && !foundWords.includes(selectedWord)) {
        setFoundWords([...foundWords, selectedWord]);
    } else if (wordsToFind.includes(reversed) && !foundWords.includes(reversed)) {
        setFoundWords([...foundWords, reversed]);
    }

    setStartCell(null);
    setCurrentCell(null);
  };

  // Efeito global para soltar o mouse fora do grid
  useEffect(() => {
    const handleGlobalUp = () => { if(isDragging) handleMouseUp(); };
    window.addEventListener('mouseup', handleGlobalUp);
    window.addEventListener('touchend', handleGlobalUp);
    return () => {
        window.removeEventListener('mouseup', handleGlobalUp);
        window.removeEventListener('touchend', handleGlobalUp);
    };
  });

  const selectedIds = isDragging ? getSelectedCells() : [];

  return (
    <div className="flex flex-col h-full max-w-lg mx-auto p-4 select-none">
      <div className="flex justify-between items-center mb-4">
        <button onClick={onExit} className="text-gray-500"><ArrowLeft /></button>
        <span className="font-bold text-indigo-800">Faltam: {wordsToFind.length - foundWords.length}</span>
      </div>

      <div 
        className="bg-white p-2 rounded-xl shadow-lg mb-4 touch-none mx-auto"
        onMouseLeave={() => { if(isDragging) handleMouseUp(); }}
      >
        <div 
          className="grid gap-0.5" 
          style={{ gridTemplateColumns: `repeat(${GRID_SIZE}, 1fr)` }}
        >
          {grid.map((row, r) => (
            row.map((letter, c) => {
              const id = `${r}-${c}`;
              const isSelected = selectedIds.includes(id);
              // Verifica se esta c√©lula faz parte de alguma palavra j√° encontrada (l√≥gica visual complexa omitida, focando no highlight da sele√ß√£o)
              // Para MVP: n√£o destacamos as c√©lulas j√° encontradas no grid permanentemente para n√£o poluir, apenas risca na lista
              
              return (
                <div 
                  key={id}
                  onMouseDown={() => handleMouseDown(r, c)}
                  onMouseEnter={() => handleMouseEnter(r, c)}
                  // Suporte a touch b√°sico
                  onTouchStart={(e) => { e.preventDefault(); handleMouseDown(r, c); }}
                  onTouchMove={(e) => {
                    e.preventDefault();
                    // L√≥gica complexa para touch move requer coordenadas da tela
                    const touch = e.touches[0];
                    const element = document.elementFromPoint(touch.clientX, touch.clientY);
                    if (element && element.dataset.coord) {
                        const [tr, tc] = element.dataset.coord.split('-').map(Number);
                        handleMouseEnter(tr, tc);
                    }
                  }}
                  data-coord={`${r}-${c}`}
                  className={`
                    w-7 h-7 sm:w-9 sm:h-9 flex items-center justify-center font-bold text-sm sm:text-lg rounded-sm cursor-pointer transition-colors
                    ${isSelected ? 'bg-indigo-500 text-white' : 'bg-gray-50 text-gray-700'}
                  `}
                >
                  {letter}
                </div>
              );
            })
          ))}
        </div>
      </div>

      <div className="flex flex-wrap gap-2 justify-center">
        {wordsToFind.map(w => {
          const isFound = foundWords.includes(w);
          return (
            <span key={w} className={`px-2 py-1 rounded-full text-xs font-bold border transition-all ${isFound ? 'bg-green-500 text-white border-green-500 scale-95 opacity-50' : 'bg-white text-gray-600 border-gray-200'}`}>
              {w}
            </span>
          );
        })}
      </div>
      
      <p className="text-center text-xs text-gray-400 mt-4 flex items-center justify-center gap-1">
        <Hand size={12} /> Arraste para selecionar as palavras
      </p>
    </div>
  );
};

// --- CRUZADINHA (Mantida intacta) ---
const CrosswordMode = ({ deck, onExit }) => {
  const [inputs, setInputs] = useState({});
  const [showHelp, setShowHelp] = useState(null);

  return (
    <div className="flex flex-col h-full max-w-md mx-auto p-4 overflow-y-auto pb-20">
      <div className="flex justify-between items-center mb-6">
        <button onClick={onExit} className="text-gray-500"><ArrowLeft /></button>
        <h2 className="font-bold text-indigo-800">Preencha os Termos</h2>
      </div>

      <div className="space-y-6">
        {deck.cartas.map((card, idx) => {
          const word = card.termo.toUpperCase();
          const isCorrect = inputs[idx] === word;
          
          return (
            <div key={idx} className="bg-white p-4 rounded-xl shadow-sm border border-gray-100">
              <div className="flex justify-between items-start mb-2">
                <span className="text-xs font-bold text-indigo-500 bg-indigo-50 px-2 py-1 rounded">#{idx + 1}</span>
                <button onClick={() => setShowHelp(showHelp === idx ? null : idx)} className="text-gray-400 hover:text-yellow-500"><HelpCircle size={18} /></button>
              </div>
              <p className="text-sm text-gray-700 mb-3 font-medium">{card.definicao}</p>
              {showHelp === idx && ( <div className="mb-3 text-xs text-yellow-600 bg-yellow-50 p-2 rounded animate-pulse">Dica: {card.dica || "..."}</div> )}

              <div className="flex gap-1 overflow-x-auto pb-2">
                {word.split('').map((char, charIdx) => (
                    <div key={charIdx} className={`w-8 h-8 flex-shrink-0 flex items-center justify-center border-2 rounded font-bold ${isCorrect ? 'bg-green-100 border-green-400 text-green-700' : 'bg-gray-50 border-gray-200 text-transparent'}`}>
                      {isCorrect ? char : ''}
                    </div>
                ))}
              </div>
              {!isCorrect && (
                <div className="flex gap-2 mt-2">
                  <input type="text" placeholder="Digite a resposta..." className="flex-1 border border-gray-300 rounded-lg px-3 py-2 text-sm uppercase outline-none focus:border-indigo-500"
                    onChange={(e) => { if(e.target.value.toUpperCase() === word) { setInputs({...inputs, [idx]: word}); }}}
                  />
                </div>
              )}
            </div>
          );
        })}
      </div>
    </div>
  );
};

// --- CRIADOR (Atualizado com IA Magic) ---
const CreatorMode = ({ onSave, onCancel }) => {
  const [step, setStep] = useState(1);
  const [title, setTitle] = useState('');
  const [method, setMethod] = useState('magic'); // magic, manual, text, pdf
  const [rawText, setRawText] = useState('');
  const [magicTopic, setMagicTopic] = useState('');
  const [cards, setCards] = useState([]);
  const [isProcessing, setIsProcessing] = useState(false);
  const fileInputRef = useRef(null);

  // GERA√á√ÉO AUTOM√ÅTICA (SIMULADA)
  const generateFromTopic = () => {
    setIsProcessing(true);
    setTimeout(() => {
        // Simula√ß√£o de resposta de IA baseada no t√≥pico
        const topicLower = magicTopic.toLowerCase();
        let generatedCards = [];
        
        if (topicLower.includes('ingl√™s') || topicLower.includes('english')) {
            generatedCards = [
                { termo: "APPLE", definicao: "A red or green fruit.", dica: "Fruit" },
                { termo: "HOUSE", definicao: "Place where people live.", dica: "Building" },
                { termo: "DOG", definicao: "Man's best friend.", dica: "Animal" },
                { termo: "WATER", definicao: "Essential liquid for life.", dica: "H2O" },
                { termo: "BOOK", definicao: "Pages with text to read.", dica: "Reading" },
                { termo: "SCHOOL", definicao: "Place to learn.", dica: "Education" },
                { termo: "CAR", definicao: "Vehicle with 4 wheels.", dica: "Transport" }
            ];
        } else if (topicLower.includes('hist√≥ria') || topicLower.includes('brasil')) {
            generatedCards = [
                { termo: "PEDRO I", definicao: "Primeiro imperador do Brasil.", dica: "Independ√™ncia" },
                { termo: "CABRAL", definicao: "Navegador portugu√™s que chegou em 1500.", dica: "Descobrimento" },
                { termo: "ESCRAVIDAO", definicao: "Trabalho for√ßado abolido em 1888.", dica: "Lei √Åurea" },
                { termo: "VARGAS", definicao: "Presidente conhecido como pai dos pobres.", dica: "Era Vargas" },
                { termo: "DITADURA", definicao: "Regime militar de 1964.", dica: "Regime" },
                { termo: "COLONIA", definicao: "Per√≠odo em que o Brasil pertencia a Portugal.", dica: "Pr√©-independ√™ncia" },
                { termo: "OURO", definicao: "Min√©rio explorado em Minas Gerais.", dica: "Ciclo econ√¥mico" }
            ];
        } else {
            // Fallback gen√©rico para qualquer outro t√≥pico
            generatedCards = [
                { termo: "CONCEITO 1", definicao: `Defini√ß√£o principal sobre ${magicTopic}.`, dica: "Importante" },
                { termo: "EXEMPLO A", definicao: `Um exemplo pr√°tico de ${magicTopic}.`, dica: "Pr√°tica" },
                { termo: "TEORIA X", definicao: "Teoria fundamental deste assunto.", dica: "Te√≥rico" },
                { termo: "DADO 1", definicao: "Estat√≠stica relevante.", dica: "N√∫mero" },
                { termo: "HISTORICO", definicao: "Como este assunto evoluiu.", dica: "Tempo" },
                { termo: "APLICACAO", definicao: "Onde isso √© usado hoje.", dica: "Uso" },
                { termo: "FUTURO", definicao: "Tend√™ncias para ${magicTopic}.", dica: "Amanh√£" }
            ];
        }
        
        setTitle(magicTopic.charAt(0).toUpperCase() + magicTopic.slice(1));
        setCards(generatedCards);
        setStep(2);
        setIsProcessing(false);
    }, 1500);
  };

  const processText = () => {
    setIsProcessing(true);
    setTimeout(() => {
      const lines = rawText.split('\n').filter(line => line.trim() !== '');
      const newCards = [];
      lines.forEach(line => {
        let parts = line.split(/[:|-]/);
        if (parts.length < 2) parts = [line, "Defini√ß√£o pendente..."];
        if (parts[0].trim().length > 0) {
          newCards.push({
            termo: parts[0].trim().toUpperCase().substring(0, 15),
            definicao: parts.slice(1).join(' ').trim(),
            dica: `Come√ßa com ${parts[0].trim().charAt(0)}`
          });
        }
      });
      setCards(newCards);
      setStep(2);
      setIsProcessing(false);
    }, 1000);
  };

  const handleFinalSave = () => {
    if (!title) { alert("D√™ um t√≠tulo para sua mat√©ria!"); return; }
    onSave({ id: Date.now().toString(), titulo: title, cartas: cards });
  };

  const updateCard = (index, field, value) => {
    const newCards = [...cards];
    newCards[index][field] = value;
    setCards(newCards);
  };

  if (step === 1) {
    return (
      <div className="flex flex-col h-full max-w-lg mx-auto p-6">
        <div className="flex justify-between items-center mb-8">
            <button onClick={onCancel} className="text-gray-500"><ArrowLeft /></button>
            <h2 className="text-xl font-bold text-gray-800">Criar Material</h2>
            <div className="w-6"></div>
        </div>

        <div className="space-y-6">
            <div className="grid grid-cols-4 gap-2">
                <button onClick={() => setMethod('magic')} className={`p-2 rounded-xl border flex flex-col items-center gap-1 ${method === 'magic' ? 'bg-indigo-50 border-indigo-500 text-indigo-700' : 'bg-white border-gray-200 text-gray-500'}`}>
                    <Sparkles size={20} /> <span className="text-[10px] font-bold">M√°gica IA</span>
                </button>
                <button onClick={() => setMethod('manual')} className={`p-2 rounded-xl border flex flex-col items-center gap-1 ${method === 'manual' ? 'bg-indigo-50 border-indigo-500 text-indigo-700' : 'bg-white border-gray-200 text-gray-500'}`}>
                    <Plus size={20} /> <span className="text-[10px] font-bold">Manual</span>
                </button>
                <button onClick={() => setMethod('text')} className={`p-2 rounded-xl border flex flex-col items-center gap-1 ${method === 'text' ? 'bg-indigo-50 border-indigo-500 text-indigo-700' : 'bg-white border-gray-200 text-gray-500'}`}>
                    <FileText size={20} /> <span className="text-[10px] font-bold">Texto</span>
                </button>
                <button onClick={() => setMethod('pdf')} className={`p-2 rounded-xl border flex flex-col items-center gap-1 ${method === 'pdf' ? 'bg-indigo-50 border-indigo-500 text-indigo-700' : 'bg-white border-gray-200 text-gray-500'}`}>
                    <Upload size={20} /> <span className="text-[10px] font-bold">PDF</span>
                </button>
            </div>

            {/* MAGIC IA MODE */}
            {method === 'magic' && (
                <div className="animate-fade-in bg-gradient-to-br from-indigo-500 to-purple-600 p-6 rounded-2xl text-white shadow-lg">
                    <Sparkles className="mb-4 text-yellow-300" size={32} />
                    <h3 className="text-lg font-bold mb-2">O app cria para voc√™!</h3>
                    <p className="text-indigo-100 text-sm mb-4">Digite um tema e nossa "IA" vai gerar flashcards, ca√ßa-palavras e cruzadinhas automaticamente.</p>
                    
                    <input 
                        className="w-full p-3 rounded-lg text-gray-800 font-bold outline-none mb-4"
                        placeholder="Ex: Sistema Solar, Verbos em Ingl√™s..."
                        value={magicTopic}
                        onChange={(e) => setMagicTopic(e.target.value)}
                    />
                    <button 
                        onClick={generateFromTopic}
                        disabled={!magicTopic || isProcessing}
                        className="w-full bg-yellow-400 text-yellow-900 font-bold py-3 rounded-lg hover:bg-yellow-300 transition flex justify-center items-center gap-2"
                    >
                        {isProcessing ? <RotateCw className="animate-spin" /> : <Wand2 />}
                        {isProcessing ? 'Criando M√°gica...' : 'Gerar Material'}
                    </button>
                </div>
            )}

            {method === 'manual' && (
                <div className="animate-fade-in">
                    <label className="block text-sm font-medium text-gray-700 mb-1">Nome da Mat√©ria</label>
                    <input className="w-full border border-gray-300 rounded-lg p-3 mb-4 outline-none" placeholder="Ex: Matem√°tica" value={title} onChange={(e) => setTitle(e.target.value)} />
                    <button onClick={() => { setCards([{termo:'', definicao:'', dica:''}]); setStep(2); }} className="w-full bg-indigo-600 text-white py-3 rounded-xl font-bold">Come√ßar do Zero</button>
                </div>
            )}

            {method === 'text' && (
                <div className="animate-fade-in">
                    <textarea className="w-full h-40 border border-gray-300 rounded-lg p-3 text-sm outline-none" placeholder="Cole seu resumo aqui..." value={rawText} onChange={(e) => setRawText(e.target.value)} />
                    <button onClick={processText} disabled={isProcessing || !rawText} className="w-full bg-indigo-600 text-white py-3 rounded-xl font-bold mt-4 flex justify-center gap-2">{isProcessing ? 'Processando...' : 'Gerar Cards'}</button>
                </div>
            )}

             {method === 'pdf' && (
                <div className="animate-fade-in border-2 border-dashed border-gray-300 rounded-xl p-8 flex flex-col items-center text-center bg-gray-50">
                    <File className="text-gray-400 mb-4" size={48} />
                    <p className="text-gray-600 font-medium mb-2">Selecione um arquivo PDF</p>
                    <input type="file" ref={fileInputRef} className="hidden" onChange={() => { setIsProcessing(true); setTimeout(() => { setCards([{termo:"PDF TERM", definicao:"Simula√ß√£o", dica:"Demo"}]); setTitle("Do PDF"); setStep(2); setIsProcessing(false); }, 1500); }} />
                    <button onClick={() => fileInputRef.current.click()} disabled={isProcessing} className="bg-white border border-gray-300 text-gray-700 px-6 py-2 rounded-lg font-bold hover:bg-gray-100">{isProcessing ? 'Lendo...' : 'Escolher Arquivo'}</button>
                </div>
            )}
        </div>
      </div>
    );
  }

  // EDITOR (Passo 2)
  return (
    <div className="flex flex-col h-full bg-gray-50">
        <div className="bg-white p-4 border-b flex justify-between items-center shadow-sm">
            <button onClick={() => setStep(1)} className="text-gray-500"><ArrowLeft /></button>
            <span className="font-bold text-gray-800">Editando: {title || 'Novo Deck'}</span>
            <button onClick={handleFinalSave} className="text-green-600 font-bold flex items-center gap-1"><Save size={18} /> Salvar</button>
        </div>

        <div className="flex-1 overflow-y-auto p-4 space-y-4">
            {cards.map((card, idx) => (
                <div key={idx} className="bg-white p-4 rounded-xl shadow-sm border border-gray-200 relative group">
                    <button onClick={() => { const newC = cards.filter((_,i)=>i!==idx); setCards(newC); }} className="absolute top-2 right-2 text-gray-300 hover:text-red-500"><Trash2 size={16} /></button>
                    <div className="mb-3">
                        <label className="text-xs font-bold text-indigo-500 uppercase">Termo</label>
                        <input value={card.termo} onChange={(e) => updateCard(idx, 'termo', e.target.value)} className="w-full border-b border-gray-200 py-1 font-bold text-gray-800 outline-none" />
                    </div>
                    <div className="mb-3">
                        <label className="text-xs font-bold text-gray-400 uppercase">Defini√ß√£o</label>
                        <textarea value={card.definicao} onChange={(e) => updateCard(idx, 'definicao', e.target.value)} className="w-full border-b border-gray-200 py-1 text-sm text-gray-600 resize-none outline-none" rows={2} />
                    </div>
                </div>
            ))}
            <button onClick={() => setCards([...cards, {termo:'', definicao:'', dica:''}])} className="w-full py-4 border-2 border-dashed border-gray-300 rounded-xl text-gray-400 font-bold flex items-center justify-center gap-2"><Plus size={20} /> Adicionar Carta</button>
            <div className="h-10"></div>
        </div>
    </div>
  );
};

// --- MAIN APP ---
export default function StudyApp() {
  const [decks, setDecks] = useState(INITIAL_DECKS);
  const [activeDeckId, setActiveDeckId] = useState(null);
  const [mode, setMode] = useState('menu'); 

  const activeDeck = decks.find(d => d.id === activeDeckId);

  const handleSaveNewDeck = (newDeck) => {
    setDecks([...decks, newDeck]);
    setMode('menu');
  };

  if (mode === 'creator') return <CreatorMode onSave={handleSaveNewDeck} onCancel={() => setMode('menu')} />;

  if (activeDeck) {
    return (
      <div className="min-h-screen bg-gray-50 font-sans">
        {mode === 'menu' && (
             <div className="min-h-screen bg-gray-50 flex flex-col items-center justify-center p-6">
                <div className="w-full max-w-md bg-white p-6 rounded-2xl shadow-xl border border-indigo-50 relative">
                    <button onClick={() => setActiveDeckId(null)} className="absolute top-6 left-6 text-gray-400 hover:text-gray-600"><ArrowLeft /></button>
                    <div className="text-center mb-8 mt-2">
                        <h2 className="text-2xl font-bold text-gray-800">{activeDeck.titulo}</h2>
                        <p className="text-sm text-gray-500">{activeDeck.cartas.length} termos</p>
                    </div>
                    <div className="space-y-3">
                        <button onClick={() => setMode('flashcards')} className="w-full flex items-center p-4 bg-blue-50 hover:bg-blue-100 rounded-xl transition group">
                            <div className="bg-blue-500 p-3 rounded-lg text-white mr-4 shadow-sm group-hover:scale-110 transition-transform"><BookOpen size={24} /></div>
                            <div className="text-left"><span className="block font-bold text-blue-900">Flashcards</span></div>
                        </button>
                        <button onClick={() => setMode('wordsearch')} className="w-full flex items-center p-4 bg-purple-50 hover:bg-purple-100 rounded-xl transition group">
                            <div className="bg-purple-500 p-3 rounded-lg text-white mr-4 shadow-sm group-hover:scale-110 transition-transform"><Search size={24} /></div>
                            <div className="text-left"><span className="block font-bold text-purple-900">Ca√ßa-Palavras</span></div>
                        </button>
                        <button onClick={() => setMode('crossword')} className="w-full flex items-center p-4 bg-teal-50 hover:bg-teal-100 rounded-xl transition group">
                            <div className="bg-teal-500 p-3 rounded-lg text-white mr-4 shadow-sm group-hover:scale-110 transition-transform"><Grid size={24} /></div>
                            <div className="text-left"><span className="block font-bold text-teal-900">Cruzadinha</span></div>
                        </button>
                    </div>
                </div>
             </div>
        )}
        {mode === 'flashcards' && <FlashcardMode deck={activeDeck} onExit={() => setMode('menu')} />}
        {mode === 'wordsearch' && <WordSearchMode deck={activeDeck} onExit={() => setMode('menu')} />}
        {mode === 'crossword' && <CrosswordMode deck={activeDeck} onExit={() => setMode('menu')} />}
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50 flex flex-col items-center p-6 font-sans">
      <div className="w-full max-w-md space-y-6 mt-10">
        <div className="text-center space-y-2 mb-8">
          <h1 className="text-4xl font-extrabold text-indigo-900 tracking-tight">StudyGenius</h1>
          <p className="text-indigo-600 font-medium">Seus materiais de estudo</p>
        </div>
        <div className="grid gap-4">
          {decks.map(deck => (
            <div key={deck.id} onClick={() => { setActiveDeckId(deck.id); setMode('menu'); }} className="bg-white p-5 rounded-xl shadow-sm border border-gray-200 flex justify-between items-center cursor-pointer hover:shadow-md hover:border-indigo-200 transition group">
                <div className="flex items-center gap-4">
                    <div className="bg-indigo-100 text-indigo-600 p-3 rounded-lg font-bold">{deck.titulo.charAt(0)}</div>
                    <div><h3 className="font-bold text-gray-800 group-hover:text-indigo-600 transition">{deck.titulo}</h3><p className="text-xs text-gray-500">{deck.cartas.length} termos</p></div>
                </div>
                <button onClick={(e) => { e.stopPropagation(); if(confirm("Excluir?")) setDecks(decks.filter(d=>d.id!==deck.id)); }} className="text-gray-300 hover:text-red-500 p-2"><Trash2 size={18} /></button>
            </div>
          ))}
          <button onClick={() => setMode('creator')} className="w-full py-4 border-2 border-dashed border-indigo-300 bg-indigo-50 rounded-xl text-indigo-600 font-bold hover:bg-indigo-100 transition flex items-center justify-center gap-2"><Plus size={20} /> Criar Nova Mat√©ria</button>
        </div>
      </div>
    </div>
  );
}
